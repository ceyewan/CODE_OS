不断的 malloc 和 free ，使得空闲空间被分割成了不同大小的小块，成为碎片，不利于后序请求。因此，这章我们的问题是：如果处理这些碎片。

#### 假设

假设一：基本的接口就像 malloc 和 free 提供的那样。

假设二：我们主要关心外部碎片。

假设三：内存一旦被分配给用户，就不可以重定位到其他位置。

假设四：分配程序所管理的是连续的一块字节区域。

#### 底层机制

##### 分割与合并

假设我们申请一字节的内存，那么分配程序就会执行所谓的分割动作：找到一块满足条件的空闲空间，将其分割，第一块返回给用户，第二块留在空闲列表中。

合并：当释放内存后，合并程序将会把这个内存之前之后（相邻）的空闲内存与之合并，形成一个较大的空闲块。

##### 追踪已分配空间的大小

free(void *ptr)接口没有块大小的参数，因此它是假定，对于给定的指针， 内存分配库可以很快确定要释放空间的大小，从而将它放回空闲列表。要完成这个任务，大多数分配程序都会在头块（header）中保存一点额外的信息，它在内存中，通常就在返回的内存块之前。

这个也说明了，你 malloc 一字节不是真的就花了一字节。

##### 嵌入空闲列表

```c
#include <stdio.h>
#include <sys/mman.h>

typedef struct node_t
{
    int size;
    struct node_t *next;
} node_t;

int main()
{
    node_t *head = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
    head->size = 4096 - sizeof(node_t);
    head->next = NULL;
}
```

我们先关注一下 mmap 函数。

```c
#include <unistd.h>    #include <sys/mman.h>

void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);

// 函数说明：mmap()用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。
```

| 参数   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| start  | 指向欲对应的内存起始地址，通常设为NULL，代表让系统自动选定地址，对应成功后该地址会返回。 |
| length | 代表将文件中多大的部分对应到内存。                           |
| prot   | 代表映射区域的保护方式，有下列组合：PROT_EXEC  映射区域可被执行；PROT_READ  映射区域可被读取；PROT_WRITE  映射区域可被写入；PROT_NONE  映射区域不能存取。 |
| flags  | 会影响映射区域的各种特性：MAP_FIXED  如果参数 start 所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。MAP_SHARED  对应射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。MAP_PRIVATE  对应射区域的写入操作会产生一个映射文件的复制，即私人的"写入时复制" (copy on write)对此区域作的任何修改都不会写回原来的文件内容。MAP_ANONYMOUS  建立匿名映射，此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。MAP_DENYWRITE  只允许对应射区域的写入操作，其他对文件直接写入的操作将会被拒绝。MAP_LOCKED  将映射区域锁定住，这表示该区域不会被置换(swap)。 在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。 |
| fd     | open()返回的文件描述词，代表欲映射到内存的文件。             |
| offset | 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。 |

不断执行分割程序，分配内存。然后遍历列表，合并相邻块，堆又形成一个整体。

##### 让堆增长

堆耗尽的时候，再次向操作系统申请更大的空间。操作系统在执行 sbrk 系统调用时，会找到空闲的物理内存页，将它们映射到请求进程的 地址空间中去，并返回新的堆的末尾地址。

#### 基本策略

##### 最优匹配

首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。

##### 最差匹配

它尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表。

##### 首次匹配

首次匹配（first fit）策略就是找到第一个足够大的块，将请求的空间返回给用户。同样， 剩余的空闲空间留给后续请求。

##### 下次匹配

从上次分配的地方开始遍历，而不是从头。

#### 其他方式

1. 分离空闲列表

如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。

2. 伙伴系统

![image-20220322232350843](https://gitee.com/ceyewan/pic/raw/master/images/image-20220322232350843.png)

虽然分配时会有碎片，但是释放后又能合并成较大的空间，还能继续利用。
