多级反馈队列（MLFQ）：解决两个问题，优化周转时间同时降低响应时间。

没有完备的知识（不知道工作时长）如何调度？从历史中学习。

#### MLFQ：基本规则

MLFQ 中有许多独立的队列，每个队列有不同的优先级。任何一个时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作。

每个队列中的多个工作，优先级相同，我们采用轮换调度。

如果一个工作不断放弃 CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。相 反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级。通过这种方式，MLFQ 在 进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。

但是这样，底层优先级的工作会被饿死。

#### 尝试1：如何改变优先级

1. 工作进入系统时，放在最高优先级
2. 工作用完整个时间片后，降低其优先级
3. 如果工作在其时间片以内主动释放 CPU ，优先级不变

##### 单个长时间

会从高优先级慢慢降到最低优先级

##### 来了个短工作

在高优先级轮转，然后运行完成。如果不知道是短工作还是长工作，那么就假设是短工作，赋予高优先级。如果真的是短工作，那么就会很快执行完；如果是长工作，会慢慢降到低优先级。

##### 如果有 I/O

主动放弃后优先级不变，这样可以保持较高优先级，然后快速执行，和用户的交互体验较好。

##### 当前 MLFQ 的一些问题

饥饿问题：长工作会被饿死。

恶意用户：调用 I/O 从而保持优先级，控制较好时可以几乎独占 CPU 。

#### 尝试2：提升优先级

- 经过一段时间 S ，将系统所有的工作重新加入最高优先级。

首先不会导致饿死问题，如果一个 CPU 密集型工作变成了交互型，当他优先级提升时，调度程序会正确的对待他。

如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。

#### 尝试3：更好的计时方式

更加完善的 CPU 计时方式：调度程序记录一个进程在某一层中消耗的总时间，而不是调度时重新计时，只要用完了自己的配额，就降低到低一级的队列中去。

- 一旦工作用完了在某一层中的时间配额（无论中间主动放弃了多少次 CPU ），就降低其优先级。

#### MLFQ 调优及其他问题

高优先级队列只有较短的时间片，有利于交互工作可以快速切换。低优先级队列中更多的是 CPU 密集型操作，配置长时间片会取得更好的效果。

最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的建议（advice），比如通过命令行工具 nice，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。
