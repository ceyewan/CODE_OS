比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。

#### 基本概念：彩票数表示份额

彩票调度背后是一个非常基本的概念：彩票数（ticket）代表了进程（或用户或其他）占 有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。

彩票调度最精彩的地方在于利用了随机性（randomness）。当你需要做出决定时，采用随机的方式常常是既可靠又简单的选择。

随机方法的优点：

1. 可以避免奇怪的边角情况
2. 随机方法和轻量
3. 随机方法很快

#### 彩票机制

调度彩票的方式：

1. 用户自行分配，想要哪个自行的快就多分配
2. 彩票转让，通过转让，一个进程可以临时将自己的彩票交给另一个进程。客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行， 客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服 务端执行结束后会将这部分彩票归还给客户端。
3. 彩票通胀，一个进程可以临时提升或降低自己有用的彩票数量。（只用于可信赖的环境）

#### 实现

![image-20220321145019307](https://gitee.com/ceyewan/pic/raw/master/images/image-20220321145019307.png)

如果进程固定当然用数组好，但是可能有些增删，所以链表更方便些。

要让这个过程更有效率，建议将列表项按照彩票数递减排序。这个顺序并不会影响算法的正确性，但能保证用最小的迭代次数找到需要的节点，尤其当大多数彩票被少数进程掌握时。

#### 一个例子

为了更好地理解彩票调度的运行过程，我们现在简单研究一下两个互相竞争工作的完成时间，每个工作都有相同数目的 100 张彩票，以及相同的运行时间 R 。设 U = Ta / Tb 。

也就是说我们希望公平的两个工作同时完成，U = 1 。但是如果工作时间很短，比如就是 R 。那么 Ta = R，Tb = 2R ，U = 0.5 ，就不公平。如果时间很长，才能发挥出随机性的公平。

#### 如何分配彩票

这是一个非常棘手的问题，系统的运行严重依赖于彩票的分配。假设用户自己知道如何分配，因此可以 给每个用户一定量的彩票，由用户按照需要自主分配给自己的工作。然而这种方案似乎什么也没有解决——还是没有给出具体的分配策略。因此对于给定的一组工作，彩票分配的问题依然没有最佳答案。（笑死，所以这只是理论存在而已）

#### 为什么不是确定的

步长调度：一个确定性的公平分配算法。

步长调度也很简单。系统中的每个工作都有自己的步长，这个值与票数值成反比。在 上面的例子中，A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数 分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个 进程的步长分别为 100、200 和 40。我们称这个值为每个进程的步长（stride）。每次进程运行后，我们会让它的计数器 [称为行程（pass）值] 增加它的步长，记录它的总体进展。

在我们的例子中，3 个进程（A、B、C）的步长值分别为 100、200 和 40，初始行程值都为 0。因此，最初，所有进程都可能被选择执行。假设选择A（任意的，所有具有同样低 的行程值的进程，都可能被选中）。A 执行一个时间片后，更新它的行程值为 100。然后运行 B，并更新其行程值为 200。最后执行 C，C 的行程值变为 40。这时，算法选择最小的行程值，是 C，执行并增加为 80（C 的步长是 40）。然后 C再次运行（依然行程值最小），行程值增加到 120。现在运行 A，更新它的行程值为 200（现在与 B 相同）。然后 C 再次连续运行两次，行程值也变为 200。此时，所有行程值再次相等，这个过程会无限地重复下去。

彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在**每个调度周期**（步长的最小公倍数）后做到完全正确。

#### 小结

这两种方法没有被广泛应用主要是因为彩票分配问题没有解决；不能很好的适合 I/O 。