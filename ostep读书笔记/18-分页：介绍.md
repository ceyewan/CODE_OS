为了解决分段会造成空间碎片化的问题，我们考虑分页方法，将空间分割成固定长度的分片。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。

#### 一个简单的例子

假设我们把 16 字节当作一个页，程序大小为 64 字节也就是 4 页，内存大小 128 字节那么就是有 8 个页帧。我们只需要将程序地址重定向到 4 个页就行了，不要求连续。把重定向关系用一个**页表**保存下来，注意：页表是每进程的数据结构。

为了处理虚拟地址，我们需要将其分成两个组件：虚拟页面号（VPN）和页内的偏移量。因为程序一共需要 64 字节，那么也就是需要 6 位来标识虚拟地址，6 位中又需要 2 位来作为 VPN ，剩下的 4 位标识页内偏移量。

#### 页表在哪里

页表可以很大，比如 32 位的地址空间，每页的大小是 4KB 也就是说偏移量需要 12 位，剩下 20 位作为 VPN 。一个 20 位的 VPN 意味着操作系统为这个进程维持 2^20 个地址转换，就算每个页表格条目（PTE）（一个转换关系）是 4 字节。那么就是 4MB 的页表大小。100 个进程就是 400 MB ，太浪费了。

暂时我们假定页表存在于操作系统管理的物理内存中。

#### 页表中究竟有什么

页表就是一种数据结构，用于将虚拟地址（或者实际上，是虚拟页号）映射到物理地址（物理帧号）。最简单的就是用一个数组来实现。操作系统通过虚拟页号（VPN）检索 该数组，并在该索引处查找页表项（PTE），以便找到期望的物理帧号（PFN）。

每个 PTE ，也就是每个映射，有许多不同的位。比如有效位，标识这个地址转换是否有效（给堆区预留的空间但是还没分配就是无效的）；比如保护位（表明页是否可以读取、写入或执行）；比如存在位（物理存储器上还是磁盘上）；比如脏位（表明页面被带入内存后是否修改过）；比如参考位（用于追踪页面是否被访问）。

#### 分页：也很慢

对于每个内存引用（无论是取指令还是显式加载或存储），分页都需要我们执行一个 额外的内存引用，以便首先从页表中获取地址转换。工作量很大！额外的内存引用开销很 大，在这种情况下，可能会使进程减慢两倍或更多。

举个例子，我们原本从内存中读一个值，现在变成了先从页表读出物理地址，然后再去真实的物理地址中读取。

#### 内存追踪

```c
int array[1000];
for (i = 0; i < 1000; i++) 
	array[i] = 0;
```

很有可能，这 1000 个值都在同一个页上，那么我们需要访问一千次页表来确定这 1000 次的映射吗？不需要，cache 会帮我们记住。对的，接下来我们需要引入 cache 了。

