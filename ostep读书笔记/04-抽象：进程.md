进程就是运行中的程序。虽然只有少量的物理 CPU 可用，但是操作系统可以提供几乎有无数个 CPU 可用的假象，来运行无数个进程。

操作系统通过虚拟化（virtualizing）CPU 来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享（time sharing）CPU 技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失， 因为如果 CPU 必须共享，每个进程的运行就会慢一点。

要实现 CPU 的虚拟化，操作系统需要一些低级机制以及高级智能。我们将低级机制称为机制（mechanism），将一些高级智能称为策略（policy）。

#### 抽象：进程

操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。

进程的机器状态（程序在运行时可以可以读取或更新的内容），包括内存、寄存器（程序计时器、栈指针、帧指针）。

- 提示：分离策略和机制

#### 进程 API

- 创建：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。
- 销毁：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出， 用户可能希望终止它们，因此停止失控进程的接口非常有用。
- 等待：有时等待进程停止运行是有用的，因此经常提供某种等待接口。
- 其他控制：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间）， 然后恢复（继续运行）
- 状态：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。

#### 进程创建：更多细节

1. 操作系统将代码和静态数据加载（load）到内存中，加载到进程的地址空间中。
2. 为程序的运行时栈分配一些内存。C 程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。
3. 操作系统为程序的堆分配一些内存。
4. 操作系统还将执行一些其他初始化任务，特别是与 I/O 相关的任务。
5. 最后，启动程序，在入口处执行，将 CPU 的控制权转移到新创建的进程中，从而程序开始执行。

#### 进程状态

- 运行状态
- 就绪状态
- 阻塞状态

#### 数据结构

操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息。比如使用进程列表来确定接下来应该运行哪个进程，比如上下文切换时保存寄存器的值。

除了运行、就绪和阻塞之外，还有其他一些进程可以处于的状态。有时候系统会有一个初始（initial）状态，表示进程在创建时处于的状态。另外，一个进程可以处于已退出但尚未清理的最终（final）状态（在基于 UNIX 的系统中，这称为僵尸状态）。这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于 UNIX 的系统中，程序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如， wait()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构。