本章将介绍一个简单的文件系统实现，称为 VSFS（Very Simple File System，简单文件系统）。

#### 思考方式

第一个方面是文件系统的数据结构（data structure）。换言之，文件系统在磁盘上使用哪 些类型的结构来组织其数据和元数据？我们即将看到的第一个文件系统（包括下面的 VSFS）使用简单的结构，如块或其他对象的数组，而更复杂的文件系统（如 SGI 的 XFS） 使用更复杂的基于树的结构。

文件系统的第二个方面是访问方法（access method）。如何将进程发出的调用，如 open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些 结构？所有这些步骤的执行效率如何？

#### 整体组织

首先，我们将磁盘分块，每一块的大小为 4KB 。我们对构建文件系统的磁盘分区可以这样理解：一系列块，每块大小为 4KB 。在大小为 N 个 4KB 块的分区中，这些块的地址为从 0 到 N - 1 。

现在我们假设 N = 64 。

为了构建文件系统，需要在这些块中存储什么。当然，首先想到的是用户数据。实际上，任何文件系统中的大多数空间都是（并且应该是）用户数据。 我们将用于存放用户数据的磁盘区域称为数据区域（data region），简单起见，将磁盘的固定部分留给这些块，例如磁盘上 64 个块的最后 56 个。

文件系统必须记录每个文件的信息。该信息是元数据
（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小， 其所有者和访问权限、访问和修改时间以及其他类似信息的事情。为了存储这些信息，文件系统通常有一个名为 inode 的结构。

为了存放 inode，我们还需要在磁盘上留出一些空间。我们将这部分磁盘称为 inode 表（inode table），它只是保存了一个磁盘上 inode 的数组。因此，假设我们将 64 个块中的 5 块用于 inode 。

还需要某种方法来记录 inode 或数据块是空闲还是已分配。因此，这种分配结构（allocation structure）是所有文件系统中必需的部分。

我们选择一种简单而流行的结构，称为位图（bitmap），一种用于数据区域（数据位图，data bitmap），另一种用于 inode 表（inode 位图，inode bitmap）。位图是一种简单的结构：每个位用于指示相应的对象/块是空闲（0） 还是正在使用（1）。这两个位图我们又分配两个块。

最后，在极简文件系统的磁盘结构设计中，还有一块。我们将 它保留给超级块（superblock）。超级块包含关于该特定文件系统的信息， 包括例如文件系统中有多少个 inode 和数据块（在这个例子中分别为 80 和 56）、inode 表的 开始位置（块 3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为 VSFS）。

![image-20220402163647085](../res/image-20220402163647085.png)

在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。

#### 文件组织：inode

名称 inode 是 index node（索引节点）的缩写，这些节点最初放在一个数组中，在访问特定 inode 时会用到该数组的索引。用于描述保存给定文件的元数据的结构，例如其长度、 权限以及其组成块的位置。

inode 如何引用数据块的位置，我们可以用**指针**来实现，每个指针都指向属于该文件的一个磁盘块。但是，inode 能够容纳的指针数量是有限的，所以我们可以采用多级指针来实现。一个指针指向一个块，那个块里面全部都是指针。

因为大多数文件都很小，用 inode 中的 12 个指针就足够了，所以更快，只需要一个间接指针用来实现大文件。

另一种方法是**基于范围的方法**，给定一个头指针和数据的 size 即可。多个范围就多个头指针和 size 。

这两种方法相比较，基于指针的方法是最灵活的，但是每个文件使用大量元数据（尤其是大文件）。 基于范围的方法不够灵活但更紧凑。特别是，如果磁盘上有足够的可用空间并且文件可以连续布局（无 论如何，这实际上是所有文件分配策略的目标），基于范围的方法都能正常工作。

**补充：基于链接的方法**

在一个 inode 中，不是有多个指针，只需要一个，指向文件的第一个块。要处理较大的文件，就在该数据块的末尾添加另一个指针等， 这样就可以支持大文件。（缺点就是像链表一样，不支持随机存取，但是可以通过 cache 来优化）

#### 目录组织

一个目录就是一个文件，也有其特定的 inode 号，内容就是目录里的东西，还包括 . 和 .. 这两个目录。

删除一个文件（例如调用 unlink()）会在目录中间留下一段空白空间，因此应该有一些方法来标记它（例如，用一个保留的 inode 号，比如 0）。这种删除是使用记录长度的一个原因：新条目可能会重复使用旧的、更大的条目，从而在其中留有额外的空间。

#### 空闲空间管理

在 VSFS 中，我们用两个简单的位图来完成这个任务。

一些 Linux 文件系统在创建新文件并需要数据块时，会寻找一系列空闲块（如 8 块）。通过找到这样一系列空闲块，然后将它们分配给新创建的文件，文件系统保证文件的一部分将在磁盘上并且是连续的，从而提高性能。

#### 访问路径：读取和写入

##### 从磁盘读取文件

当你发出一个 open("/foo/bar", O_RDONLY)调用时，文件系统首先需要找到文件 bar 的 inode，从而获取关于该文件的一些基本信息（权限信息、文件大小等等）。为此，文件系统必须能够找到 inode，但它现在只有完整的路径名。文件系统必须遍历（traverse）路径名， 从而找到所需的 inode。

基本步骤是通过根目录的 inode 找到其中的内容，然后找到 foo 的 inode ，继续查找其内容，然后找到 bar 的 inode ，从而找到 bar 里面的内容。然后文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分 配一个文件描述符，并将它返回给用户。读取完成后释放文件描述符。

路径越深，需要的 I/O 操作越多。

##### 写入磁盘

写入也需要先打开。

与读取不同，写入文件也可能会分配（allocate）一个块（除非块被覆写）。当写入一个新文件时，每次写入操作不仅需要将数据写入磁盘，还必须首先决定将哪个块分配给文件， 从而相应地更新磁盘的其他结构（例如数据位图和 inode）。因此，每次写入文件在逻辑上会 导致 5 个 I/O：一个读取数据位图（然后更新以标记新分配的块被使用），一个写入位图（将 它的新状态存入磁盘），再是两次读取，然后写入 inode（用新块的位置更新），最后一次写 入真正的数据块本身。

写入的工作量更大。要创建一个文件，文件系统不仅要分配一个 inode，还要在包含新文件的目录中分配空间。这样做的 I/O 工作总量 非常大：一个读取 inode 位图（查找空闲 inode），一个写入 inode 位图（将其标记为已分配）， 一个写入新的 inode 本身（初始化它），一个写入目录的数据（将文件的高级名称链接到它 的 inode 号），以及一个读写目录 inode 以便更新它。如果目录需要增长以容纳新条目，则还 需要额外的 I/O（即数据位图和新目录块）。

#### 缓存和缓冲

我们看到上面，读取和写入的代价是昂贵的，因此，大多数文件系统积极使用系统内存（DRAM） 来缓存重要的块。

读的时候缓冲可以不用每次都从根目录开始查找；写缓冲可以将多个写入操作同时执行，同时改变 inode 等，均摊时间。

我们也能通过 fsync() 函数来避免由于写入缓冲导致的意外数据丢失。



