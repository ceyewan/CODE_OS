上一章，我们解决了页表的一个问题：转换速度不行。这一章，我们来看另一个问题，内存消耗太大。

#### 简单的解决方案：更大的页

总共 32 位，偏移量大了，VPN 就会减小。但是页大了，用不完又会造成页内浪费（就像我们的书一样，某一页只写了一部分）。

#### 混合方法：分页和分段

杂合是一种很好的方法。我们的杂合方法不是为进程的整个地址空间提供单个页表，而是为每个逻辑分段提供一个。我们可能有 3 个页表，地址空间的代码、堆和栈部分各有一个。主要还是因为栈和堆中间有大部分区域还未使用，我们就不把它映射。先分段，减少中间部分的使用，然后将三个段分别建立页表，并设置相应的寄存器。

![image-20220323195449539](https://gitee.com/ceyewan/pic/raw/master/images/image-20220323195449539.png)

以这种方式，与线性页表相比，杂合方法实现了显著的内存节省。栈 和堆之间未分配的页不再占用页表中的空间（仅将其标记为无效）。

#### 多级页表

另一种方法并不依赖于分段，但也试图解决相同的问题：如何去掉页表中的所有无效区域，而不是将它们全部保留在内存中？我们将这种方法称为多级页表（multi-level page table），因为它将线性页表变成了类似树的东西。字典树，明白了吗？大部分不需要的就先不搞空间了。（既保持了空间的紧凑，又支持稀疏的地址空间）

![image-20220323200120911](https://gitee.com/ceyewan/pic/raw/master/images/image-20220323200120911.png)

但是，这样多层后需要消耗更高的时间成本。没有尽善尽美的方法，只能保持中庸。

##### 详细的多级示例

![image-20220323200620207](https://gitee.com/ceyewan/pic/raw/master/images/image-20220323200620207.png)

##### 超过两级

![image-20220323200823765](https://gitee.com/ceyewan/pic/raw/master/images/image-20220323200823765.png)

##### 地址转换过程：记住 TLB

在任何复杂的多级页表访问发生之前，硬件首先检查 TLB。在命中 时，物理地址直接形成，而不像之前一样访问页表。只有在 TLB 未命中时，硬件才需要执 行完整的多级查找。在这条路径上，可以看到传统的两级页表的成本：两次额外的内存访问来查找有效的转换映射。

#### 反向页表

因为每个进程都有一个页表，进程一多，就不划算了。因此我们可以反向建表，基于物理地址来建表。我们通过前面简单的方法得到物理地址之后，就去反向页表查找（可以利用哈希表查找）。如果能查找到自己的虚拟地址，那么说明映射是对应的，就能直接从 TLB 拿数据；如果查找到的虚拟地址不是自己，那么就是别的进程的，自己未命中，然后就去内存读取，写入 TLB。

#### 将页表交换到磁盘

太大了那就存到磁盘里吧，不就好了么

