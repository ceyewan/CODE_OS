#### 有哪些类型的缺陷

可以分为非死锁缺陷和死锁缺陷。

#### 非死锁缺陷

包括违反原子性缺陷和错误顺序缺陷。

##### 违反原子性缺陷

更正式的违反原子性的定义是：“违反了多次内存访问中预期的可串行 性（即代码段本意是原子的，但在执行中并没有强制实现原子性）”。我们只需要给变量加锁，保证其原子性即可。

##### 违反顺序缺陷

违反顺序更正式的定义是：“两个内存访问的预期顺序被打破了（即A应该在 B之前执 行，但是实际运行中却不是这个顺序）”。我们可以通过强制顺序来修复这种缺陷，比如条件变量。

#### 死锁缺陷

线程一等待线程二，线程二等待线程一，就会发生死锁。

##### 为什么发生死锁

1. 大型的代码库里面，组件之间会有复杂的依赖。以操作系统为例，虚拟内存系统在需要访问文件系统才能从磁盘读到内存页；文件系统随后又要和虚拟内存交互，去申请一页内存，以便存放读到的块。因此，在设计大型系统的锁机制时，你必须要仔细地去避免循环依赖导致的死锁。
2. 封装，有些细节被隐藏，从而导致死锁。

```java
Vector v1, v2; 
v1.AddAll(v2); // 假设这个语句先给 v1 加锁，再给 v2 加锁，那么就可能和下面这个语句并发时发生死锁。
v2.AddAll(v1);
```

##### 产生死锁的条件

- 互斥：线程对于需要的资源进行互斥的访问
- 持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。
- 非抢占：线程获得的资源（例如锁），不能被抢占。
- 循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。

##### 预防

1. 循环等待

获取锁时提供一个**全序**（total ordering），假如系统就两个锁，那么我们每次都先申请锁一，再申请锁二。

全序很难做到的时候，可以采用**偏序**。

我们可以通过**锁的地址**来确定锁的顺序。

2. 持有并等待

我们可以将抢锁行为变成原子性来解决这个问题。比如需要有两个锁，为了避免获取了锁一而等待锁二，我们可以用一个锁将获取这两个锁的操作锁起来，实现原子操作。但是这也有问题，如果封装后，就很容易搞错。 而且降低了并发，一次抢了两个锁。

3. 非抢占

我们可以当得不到想要资源的时候，让出我们持有的资源：

```c
top:
	lock(L1);
    if (trylock(L2) == -1) { 
        unlock(L1); 
        goto top;
    }
```

但是可能会让两个原本是死锁的线程变成活锁。就好像你迎面走过来一个人，你想着让一下，往左边走，结果他也往左边走，你想往右走，结果他也往右走。解决办法也比较简单，让两个线程的反应速度不一样就好了。

4. 互斥

通过强大的硬件指令，我们可以构造出不需要锁的数据结构。

假设我们有比较并交换指令（原子指令）（将第一个参数和第二个参数比较，相等就将第一个参数换成第三个参数并返回 1 ，不相等就返回 0 。

那么我们可以通过下面这种方式实现增加值：

```c
void AtomicIncrement(int *value, int amount) {
	do { 
        int old = *value; 
    } while (CompareAndSwap(value, old, old + amount) == 0); 
}
```

实现向链表中插入元素：

```
void insert(int value) {
	node_t *n = malloc(sizeof(node_t)); 
	assert(n != NULL); 
	n->value = value; 
	do {
		n->next = head; 
	} while (CompareAndSwap(&head, n->next, n) == 0); }
```

##### 通过调度避免死锁

##### 检查和恢复

最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。举个例子， 如果一个操作系统一年死机一次，你会重启系统，然后愉快地（或者生气地）继续工作。