#### 早期系统

并没有多少抽象，物理地址暴露。

#### 多道程序和时分共享

多道程序系统时代：其中多个进程在给定时间准备运行，比如当有一个进程在等待 I/O 操作的时候，操作系统会切换这些进程，这样增加了 CPU 的有效利用 率（utilization）。

分时系统：许多人意识到批量计算的局限性，尤其是程序员本身，他们厌倦了长时间的（因此也是低效率的）编程—调试循环。交互性（interactivity）变得很重要，因为许多用户可能同时在使用机器，每个人都在等待（或希望）他们执行的任务及时响应。

一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间，然后停止它，并将它所有的状态信息保存在**磁盘**上（包含所有的物理内存），加载其他进程的状态信息，再运行一段时间，这就实现了某种比较粗糙的机器共享。但是，这太慢了。

因此我们可以将进程信息放在内存中。多个程序同时驻留izai内存中，使得保护成为重要问题。

#### 地址空间

操作系统提供一个易用的物理内存抽象，这个抽象叫做地址空间，是运行的程序看到的系统中的内存。

一个进程的地址空间包含运行的程序的所有内存状态（包括代码区、堆区、栈区）。

隔离是建立可靠系统的关键原则。如果两个实体相互隔离，这意味着一个实体的失败不会影响另一个实体。操作系统力求让进程彼此隔离，从而防止相互造成伤害。

#### 目标

虚拟内存系统的一个主要目标是透明（透明表示很难被注意到），让程序感知不到内存被虚拟化的事实。

另一个目标是效率，虚拟化应该尽可能高效，时间上不会使得程序运行时更慢，空间上不需要太多额外空间。

第三个目标时保护。操作系统应该确保进程受到保护，不会受其他进程的影响，操作系统也不会受进程影响。

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf("The address of code is %p\n", (void *)main);
    int *x = (int *)malloc(sizeof(int));
    printf("The address of stack is %p\n", &x);
    printf("The address of heap is %p\n", x);
    return 0;
}
```

![image-20220321201512246](https://gitee.com/ceyewan/pic/raw/master/images/image-20220321201512246.png)

我们可以看到代码区和堆区接近，栈区在另一边。但是实际上，这些地址都不是真的，不过我们可以当成真的就好了。

