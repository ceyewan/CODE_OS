#### 系统架构

CPU 通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能 I/O 设备通过常规的 I/O 总线（I/O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下 面是外围总线（peripheral bus），比如 SCSI、SATA或者 USB。它们将最慢的设备连接到系 统，包括磁盘、鼠标及其他类似设备。

采用这种分层架构的原因和存储单元类似，价格与速度的平衡。

#### 标准设备

包含两部分重要组件：接口和内部结构，接口是为了让系统软件来控制它的操作。内部结构用来实现设备展示给系统的接口。

#### 标准协议

一个简化的设备接口包含 3 个寄存器：一个状态寄存器，可以读取并查看设备的状态；一个命令寄存器，用于通知设备执行某个具体任务；一个数据寄存器，用于将数据传给设备或从设备接收数据。

一个典型的协议：

第 1 步，操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。

第 2 步，操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写 入操作，将一个磁盘块（比如 4KB）传递给设备。

第 3 步，操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。

最后一步， 操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指 示成功或失败的错误码）。

#### 利用中断减少CPU开销

有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发 CPU 跳转执行操作系统预先定义好的中断服务例程（Interrupt Service Routine，ISR），或更为简单的中断处理程序（interrupt handler）。

如果设备特别快，那么最好的办法是轮询；如果特别慢，那么最好的办法是中断；如果时快时慢，那么混合策略会更好（先尝试轮询一段时间，然后中断）。

另一个最好不要使用中断的场景是网络。网络端收到大量数据包，如果每一个包都发生一次中断，那么有可能导致操作系统发生活锁（livelock），即不断处理中断而无法处理用 户层的请求。例如，假设一个 Web 服务器因为“点杠效应”而突然承受很重的负载。这种 情况下，偶尔使用轮询的方式可以更好地控制系统的行为，并允许 Web 服务器先服务一些 用户请求，再回去检查网卡设备是否有更多数据包到达。

另一个基于中断的优化就是合并（coalescing）。设备在抛出中断之前往往会等待一小段 时间，在此期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而 降低处理中断的代价。

#### 利用DMA进行更高效的数据传送

CPU 将数据传输到磁盘，然后进行 I/O 操作，将数据传输到磁盘这种操作可以由 DMA 完成。

DMA引擎是系统中的一个特殊设备， 它可以协调完成内存和设备间的数据传递，不需要 CPU 介入。为了能够将数据传送给设备，操作系统会通过编程告诉 DMA 引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以 处理其他请求了。当 DMA 的任务完成后，DMA 控制器会抛出一个中断来告诉操作系统自 己已经完成数据传输。

#### 设备交互的方法

方法一：使用明确的 I/O 指令。

这些指令规定了操作系统将数据发 送到特定设备寄存器的方法，从而允许构造上文提到的协议。

例如在 x86 上，in 和 out 指令可以用来与设备进行交互。当需要发送数据给设备时，调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口。执行这个指令就可以实现期望的行为。

方法二：内存映射 I/O

通过这种方式，硬件将设备寄存器 作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入） 到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。

#### 纳入操作系统：设备驱动程序

每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用。

通过抽象技术来解决。

在最底层，操作系统的一部 分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序（device driver），所 有设备交互的细节都封装在其中。

因为所有需要插入系统的设备都需要安装对应的驱动程序，所以久而久之，驱动程序的代码在整个内核代码中的占比越来越大。

#### 案例研究：简单的IDE磁盘驱动程序

IDE 硬盘暴露给操作系统的接口比较简单，包含 4 种类型的寄存器，即控制、命令块、状态和错误。在 x86 上，利用 I/O 指令 in 和 out 向特定的 I/O 地址读取或写入时，可以访问这些寄存器。

- 等待驱动就绪
- 向命令寄存器写入参数
- 开启 I/O
- 数据传送（针对写请求）
- 中断处理
- 错误处理

#### 小结

我们介绍了中断和DMA两种技术用于提高设备的效率，介绍了两种访问设备寄存器的方式，I/O 指令和内存映射 I/O 。

