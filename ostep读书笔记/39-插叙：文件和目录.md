到目前为止，我们看到了两项关键操作系统技术的发展：进程，它是虚拟化的 CPU； 地址空间，它是虚拟化的内存。在这两种抽象共同作用下，程序运行时就好像它在自己的 私有独立世界中一样，好像它有自己的处理器（或多处理器），好像它有自己的内存。

在这一部分，我们加上虚拟化拼图中更关键的一块：持久存储（persistent storage）。永 久存储设备永久地（或至少长时间地）存储信息，如传统硬盘驱动器（hard disk drive）或 更现代的固态存储设备（solid-state storage device）。

#### 文件和目录

- 文件：文件就是 一个线性字节数组，每个字节都可以读取或写入。每个文件都有一个与其关联的 innode 号。
- 目录：目录中的每个条目 都指向文件或其他目录。通过将目录放入其他目录中，用户可以构建任意的目录树。

#### 创建文件

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
int main()
{
    int fd = open("foo.txt", O_CREAT | O_WRONLY | O_TRUNC);
    close(fd);
    return 0;
}
```

- fd：文件描述符
- O_CREAT：创建文件
- O_WRONLY：只能写
- O_TRUNC：删除文件中的现有内容

#### 读写文件

strace 用于跟踪命令。

```shell
echo hello > foo.txt
strace cat foo.txt
```

每个正在运行的进程已经打开了 3 个文件：标准输入（进程可以读取以接收输入），标准输出（进程 可以写入以便将信息显示到屏幕），以及标准错误（进程可以写入错误消息）。这些分别由 文件描述符 0、1 和 2 表示。因此，当你第一次打开另一个文件时（如上例所示），它几乎 肯定是文件描述符 3。

#### 读取写入，但不按顺序

有时能够读取或写入文件中的特定偏移量是有用的。例如，如果你在文本文件 上构建了索引并利用它来查找特定单词，最终可能会从文件中的某些随机（random）偏移量中读取数据。为此，我们将使用 lseek()系统调用。

```c
off_t lseek(int fildes, off_t offset, int whence);
```

第一个参数是熟悉的（一个文件描述符）。第二个参数是偏移量，它将文件偏移量定位 到文件中的特定位置。第三个参数，由于历史原因而被称为 whence，明确地指定了搜索的 执行方式。

#### 用 fsync（）立即写入

大多数情况下，当程序调用 write()时，它只是告诉文件系统：请在将来的某个时刻，将此数据写入持久存储。出于性能的原因，文件系统会将这些写入在内存中缓冲（buffer）一 段时间（例如 5s 或 30s）。在稍后的时间点，写入将实际发送到存储设备。

当进程针对特定文件描述符调用 fsync()时， 文件系统通过强制将所有脏（dirty）数据（即尚未写入的）写入磁盘来响应，针对指定文件 描述符引用的文件。一旦所有这些写入完成，fsync()例程就会返回。

```

```

