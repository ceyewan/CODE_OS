多处理器系统的出现，使得操作系统遇到了一个新的问题：多处理器调度。

#### 背景：多处理器架构

在单 CPU 系统中，存在多级的硬件缓存（hardware cache），一般来说会让处理器更快地执行程序。缓存是很小但很快的存储设备，通常拥有内存中最热的数据的备份。相比之下，内存很大且拥有所有的数据，但访问速度较慢。通过将频繁访问的数据放在缓存中， 系统似乎拥有又大又快的内存。

缓存依赖于：时间局部性和空间局部性

如果系统有多个处理器，并共享同一个内存，会怎样呢？CPU1 修改了 A 的值只写入了 CPU1 的缓存，并没有写入内存，那么 CPU2 再次访问内存得到的就不是正确的值。这个问题称为**缓存一致性问题**。

硬件提供了这个问题的基本解决方案：通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探（bus snooping）。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果 CPU 发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除）， 或更新（update）它（修改为新值）。

#### 别忘了同步

跨 CPU 访问（尤其是写入）共享数据或数据结构时，需要使用互斥原语（比如锁），才能保证正确性。这里只需要一个互斥锁（即 pthread_mutex_t m;），然后在函数开始时调用 lock(&m)，在结束时调用 unlock(&m)，确保代码的执行如预期。我们会看到，这里依然有问题，尤其是性能方面。

#### 最后一个问题：缓存亲和度

一个进程的缓存在 CPU1 上，中断后再次执行要尽量将进程保持在同一个 CPU 上，避免加载缓存，称为**缓存亲和性**。

#### 单队列调度

最基本的方式是简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列 中，我们称之为单队列多处理器调度（Single Queue Multiprocessor Scheduling，SQMS）。这 个方法最大的优点是简单。它不需要太多修改，就可以将原有的策略用于多个 CPU，选择最适合的工作来运行（例如，如果有两个 CPU，它可能选择两个最合适的工作）。

缺点：

1. 缺乏可拓展性（为了同步，加锁可能会损失大量性能）
2. 缓存亲和性（保证某些进程固定在某些 CPU）

#### 多队列调度

每个 CPU 一个队列。顺利解决上面两个问题

新的问题，负载不均。某个 CPU 执行两个进程，另一个 CPU 只执行一个进程。

解决办法：迁移。比如 CPU1 有一个进程 A ，CPU2 有两个进程 B 和 C，那么就将 B 在 CPU1 和 CPU2 上面不断迁移。

一个基本的方法是采用一种技术，名为工作窃取（work stealing）。通过这种方法， 工作量较少的（源）队列不定期地“偷看”其他（目标）队列是不是比自己的工作多。如果目标队列比源队列（显著地）更满，就从目标队列“窃取”一个或多个工作，实现负载均衡。

#### Linux 多处理器调度

一直以来，Linux 上存在 3 种不同的调度程序：O(1)调度程序、完全公平调度程序（CFS）以及 BF 调度程序（BFS）。